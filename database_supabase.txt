-- =========================================================
--  DATABASE: waste_classification (Supabase / PostgreSQL)
-- =========================================================

-- 1ï¸âƒ£ Schema
CREATE SCHEMA IF NOT EXISTS public;

-- 2ï¸âƒ£ HÃ m cáº­p nháº­t timestamp chung
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =========================================================
--  USERS TABLE
-- =========================================================
DROP TABLE IF EXISTS public.users CASCADE;

CREATE TABLE public.users (
    user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role TEXT CHECK (role IN ('user', 'admin')) DEFAULT 'user',
    avatar_url VARCHAR(255),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TRIGGER trigger_users_updated_at
BEFORE UPDATE ON public.users
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- trÆ°á»ng name,password_hash cho cÃ³ thá»ƒ null
ALTER TABLE public.users
ALTER COLUMN name DROP NOT NULL;
ALTER TABLE public.users
ALTER COLUMN password_hash DROP NOT NULL;

-- =========================================================
--  IMAGES TABLE
-- =========================================================
DROP TABLE IF EXISTS public.images CASCADE;

CREATE TABLE public.images (
    image_id SERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES public.users(user_id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    status TEXT CHECK (status IN ('uploaded','processing','done','failed')) DEFAULT 'uploaded',
    upload_time TIMESTAMP DEFAULT NOW(),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TRIGGER trigger_images_updated_at
BEFORE UPDATE ON public.images
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

ALTER TABLE public.images ENABLE ROW LEVEL SECURITY;

-- =========================================================
--  WASTE_CATEGORIES TABLE
-- =========================================================
DROP TABLE IF EXISTS public.waste_categories CASCADE;

CREATE TABLE public.waste_categories (
    category_id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    bin_color VARCHAR(50),
    guide_text TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TRIGGER trigger_waste_categories_updated_at
BEFORE UPDATE ON public.waste_categories
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

ALTER TABLE public.waste_categories ENABLE ROW LEVEL SECURITY;

-- =========================================================
--  AI_MODELS TABLE
-- =========================================================
DROP TABLE IF EXISTS public.ai_models CASCADE;

CREATE TABLE public.ai_models (
    model_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    version VARCHAR(50) NOT NULL,
    description TEXT,
    accuracy FLOAT,
    precision FLOAT,
    recall FLOAT,
    f1_score FLOAT,
    deployed_at TIMESTAMP DEFAULT NOW(),
    file_path VARCHAR(255) NOT NULL,
    is_active BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE (name, version)
);

CREATE TRIGGER trigger_ai_models_updated_at
BEFORE UPDATE ON public.ai_models
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

ALTER TABLE public.ai_models ENABLE ROW LEVEL SECURITY;

-- =========================================================
--  PREDICTIONS TABLE
-- =========================================================
DROP TABLE IF EXISTS public.predictions CASCADE;

CREATE TABLE public.predictions (
    prediction_id SERIAL PRIMARY KEY,
    image_id INT NOT NULL REFERENCES public.images(image_id) ON DELETE CASCADE,
    category_id INT REFERENCES public.waste_categories(category_id) ON DELETE SET NULL,
    model_id INT REFERENCES public.ai_models(model_id) ON DELETE SET NULL,
    confidence DECIMAL(5,4) CHECK (confidence >= 0 AND confidence <= 1),
    bbox_x1 FLOAT,
    bbox_y1 FLOAT,
    bbox_x2 FLOAT,
    bbox_y2 FLOAT,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TRIGGER trigger_predictions_updated_at
BEFORE UPDATE ON public.predictions
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

ALTER TABLE public.predictions ENABLE ROW LEVEL SECURITY;

-- =========================================================
--  FEEDBACKS TABLE
-- =========================================================
DROP TABLE IF EXISTS public.feedbacks CASCADE;

CREATE TABLE public.feedbacks (
    feedback_id SERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES public.users(user_id) ON DELETE CASCADE,
    image_id INT NOT NULL REFERENCES public.images(image_id) ON DELETE CASCADE,
    comment TEXT,
    corrected_category_id INT REFERENCES public.waste_categories(category_id) ON DELETE SET NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TRIGGER trigger_feedbacks_updated_at
BEFORE UPDATE ON public.feedbacks
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

ALTER TABLE public.feedbacks ENABLE ROW LEVEL SECURITY;

-- =========================================================
-- ðŸ” PHÃ‚N QUYá»€N (RLS POLICIES)
-- =========================================================

-- ===================== USERS =====================
CREATE POLICY "Users can view own profile"
ON public.users
FOR SELECT USING (auth.uid()::text = user_id::text);

CREATE POLICY "Users can update own profile"
ON public.users
FOR UPDATE USING (auth.uid()::text = user_id::text);

CREATE POLICY "Admins can manage all users"
ON public.users
FOR ALL USING (
  EXISTS (SELECT 1 FROM public.users u WHERE u.user_id::text = auth.uid()::text AND u.role = 'admin')
);

-- ===================== IMAGES =====================
CREATE POLICY "Users can insert their own images"
ON public.images
FOR INSERT WITH CHECK (auth.uid()::text = user_id::text);

CREATE POLICY "Users can view their own images"
ON public.images
FOR SELECT USING (auth.uid()::text = user_id::text);

CREATE POLICY "Users can delete their own images"
ON public.images
FOR DELETE USING (auth.uid()::text = user_id::text);

CREATE POLICY "Admins can manage all images"
ON public.images
FOR ALL USING (
  EXISTS (SELECT 1 FROM public.users u WHERE u.user_id::text = auth.uid()::text AND u.role = 'admin')
);

-- ===================== PREDICTIONS =====================
CREATE POLICY "Users can view predictions for their images"
ON public.predictions
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.images i
    WHERE i.image_id = image_id AND i.user_id::text = auth.uid()::text
  )
);

CREATE POLICY "Admins can manage all predictions"
ON public.predictions
FOR ALL USING (
  EXISTS (SELECT 1 FROM public.users u WHERE u.user_id::text = auth.uid()::text AND u.role = 'admin')
);

-- ===================== FEEDBACKS =====================
CREATE POLICY "Users can insert feedback for their images"
ON public.feedbacks
FOR INSERT WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.images i
    WHERE i.image_id = image_id AND i.user_id::text = auth.uid()::text
  )
);

CREATE POLICY "Users can view their feedbacks"
ON public.feedbacks
FOR SELECT USING (auth.uid()::text = user_id::text);

CREATE POLICY "Admins can manage all feedbacks"
ON public.feedbacks
FOR ALL USING (
  EXISTS (SELECT 1 FROM public.users u WHERE u.user_id::text = auth.uid()::text AND u.role = 'admin')
);

-- ===================== WASTE_CATEGORIES =====================
CREATE POLICY "Anyone can read waste categories"
ON public.waste_categories
FOR SELECT USING (true);

CREATE POLICY "Only admins can modify waste categories"
ON public.waste_categories
FOR ALL USING (
  EXISTS (SELECT 1 FROM public.users u WHERE u.user_id::text = auth.uid()::text AND u.role = 'admin')
);

-- ===================== AI_MODELS =====================
CREATE POLICY "Anyone can view active models"
ON public.ai_models
FOR SELECT USING (is_active = TRUE);

CREATE POLICY "Only admins can manage models"
ON public.ai_models
FOR ALL USING (
  EXISTS (SELECT 1 FROM public.users u WHERE u.user_id::text = auth.uid()::text AND u.role = 'admin')
);
